177,0
S,CreateModularCurveRec,"Input: G : an open subgroup of GL(2,Zhat) 	 H : the open subgroup of SL(2,Zhat) that is the intersection of G with SL(2,Zhat) Output: A record of type ""ModularCurveRec"" that encodes the modular curve X_G with some basic and useful invariants computed",0,2,0,0,0,0,0,0,0,178,,0,0,178,,270,-38,-38,-38,-38,-38
S,CreateModularCurveRec,"CreateModularRec where G has level dividing N and its image in GL(2,Z/NZ) is generated by gens",0,2,0,0,0,0,0,0,0,82,,0,0,148,,270,-38,-38,-38,-38,-38
S,CreateModularCurveRec,CreateModularCurveRec with H computed directly,0,1,0,0,0,0,0,0,0,178,,270,-38,-38,-38,-38,-38
S,ModularFormToSequence,"Consider a modular form f for the modular curve M whose coefficients lie in Q(zeta_N), and let mult be a sequence of nonnegative integers with the same numbering as the cusps of M. Returns a finite sequence in Q(zeta_N) that consists of the first mult[i]+1 terms of the q-expansion of f at the i-th cusp of M for all i (with a chosen ordering). If ""OverQ"" is true, uses a basis of Q(zeta_N) over Q to obtain a matrix with rational entries instead",0,4,0,0,0,0,0,0,0,148,,0,0,82,,0,0,82,,0,0,270,,82,-38,-38,-38,-38,-38
S,SequenceToModularForm,"This is the reverse process of the function ""ModularFormToSequence""",0,4,0,0,0,0,0,0,0,-1,,0,0,-1,,0,0,-1,,0,0,-1,,270,-38,-38,-38,-38,-38
S,EisensteinFormsWeight1,"Input: N: an integer > 2 prec: a positive integer Output: An array E indexed by pairs [a,b] with a and b in Z/NZ. The term of E indexed by [a,b] is 2N times the q-expansion of the Eisenstein series E_(a,b)^1 up to O(qN^(prec)); it is given as a power series in qN:=q^(1/N) with coefficients in the cyclotomic field Q(zeta_N). For the definition of the Eisenstein series see section 2 of ""Fourier expansion at cusps"" by Brunault and Neururer. Remark: the extra factor of 2N ensures that all the coefficients are integral",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,457,-38,-38,-38,-38,-38
S,FindCuspData,"Consider a modular curve M=X_G given by a subgroup G of GL_2(Zhat). Let H be the intersection of G with SL(2,Zhat). Input: M : a record of type ""ModularCurveRec"" A : a matrix in SL(2,Zhat) given modulo an integer divisible by M`sl2level. Output: a triple of integers [i,j,e] such that A and e * M`cusps[i] * [1,1;0,1]^j lie in the same coset HSL(2,Zhat), where cusps[i] is the fixed matrix in SL(2,Z) describing the i-th cusp of M and e is 1 or -1. When G contains -I, we always choose e=1",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,82,-38,-38,-38,-38,-38
S,SturmPrecision,"Input: an integer k>1 and a record M that corresponds to a modular curve. Let Gamma be the congruence subgroup corresponding to the modular curve. For a modular form f on Gamma of weight k>1, let Z_f be the total number of zeros of f, counted with multiplicities, at the cusps of the modular curve. Output: a rational number B such that Z_f>B if and only if f=0",0,2,0,0,0,0,0,0,0,270,,0,0,148,,267,-38,-38,-38,-38,-38
S,FindModularFormsWithVanishingConditions,"Input: M : a record of type ""ModularCurveRec"" with a Q-basis M`F of M_(k,G) already computed. mult : is a sequence of nonnegative integers of the same length as cusps:=M`cusps Let V be the Q-subspace of M_(k,G) consisting of modular forms so that the vanishing of f at the i-th cusp cusps[i]*infty is at least mult[i] for all i. (the parameters ""lll"" and ""saturation"" give some control on how LLL and Saturation is done; these should pprobably be left alone!) Output: Returns the record M with the entry M`F0 being a basis of the Q-vector space V with the same conventions as the basis M`F of M_(k,G). Let d be the dimension of V over K_G (we will have d=#M`F0 div M`KG_degree). The first d modular forms in the sequence M`F0 will be a basis of V over K_G (moreover, they are linearly independent over Cthe complex numbers). The precision of all modular forms will be increased on the fly if required to enforce vanishing conditions",0,2,0,0,0,0,0,0,0,82,,0,0,270,,270,-38,-38,-38,-38,-38
S,FindCuspForms,"Applies ""FindModularFormsWithVanishingConditions"" with mult:=[1,1,...,1]",0,1,0,0,0,0,0,0,0,270,,270,-38,-38,-38,-38,-38
S,EvaluateAtMonomialsOfDegree,"Input F : a sequence of n>0 elements in some ring d : a positive integer. Output: An array A such that for nonnegative integers e_1,..,e_n that sum to d, A[[e_1,..,e_d]] is the product of F[i]^(e_i). This function could be greatly improved but it is better than the most naive implementation",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,457,-38,-38,-38,-38,-38
S,FindRelationsOverKG,"Input: M: a record describing the modular curve X_G F: a finite sequence of modular forms in some M_(k,G) (each modular form is given as a sequence of q-expansions corresponding to the cusps of the modular curve). We further assume all the q-expansions have coefficients in Q(zeta_N), where N=M`N. d: a positive integer With F=[f_1,..,f_n], let V be the K_G-vector space consisting of homomogeneous polynomials P in K_G[x_1,..,x_n] of degree d with P(f_1,..,f_n)=0. Output: - A basis ""psi"" of a K_G-vector space of homogenous degree d polynomials in K_G[x_1,..,x_n] that contains a basis of V (and might be larger). If modular forms in F are computed to a high enough precision, psi will actually be a basis of V. - A boolean b that is true when the parameter ""Proof"" is set to true and an application of the Sturm bound verifies that psi is a basis of V. When ""Proof"" is set to true, the parameter ""k"" needs to be the weight of the modular forms. An integer t so that for each h in psi, the sum of the orders of the zeros of h(f_1,..,f_n) at the cusps is at least t. (This integer and Sturm's bound can sometimes be used to prove vanishing and verify that psi is a basis of V) When ""OverQ"" is true, a basis of V as a Q-vector space is returned instead. When ""lll"" is true, we use the LLL algorithm to try to make the polynomials nicer. When ""dim_only"" is true, the function instead returns only the cardinality of psi (this can be be faster than actually computing psi)",0,3,0,0,0,0,0,0,0,148,,0,0,82,,0,0,270,,82,-38,-38,-38,-38,-38
S,FindCanonicalModel,"Input: M: a record of type ModularCurveRec (for example produced as output of CreateModularCurveRec) that corresponds to a modular curve X_G with genus g at least 3. Output: An updated record M. The first g elements of M`F0 will be a basis f_1,..,f_g of the K_G-subspace of M_(k,G) consisting of cusps forms. These cusp forms define the canonical map X_G -> P^(g-1)_(K_G); the image is a curve C which is defined by the equations in the sequence M`psi. Moreover, M`psi consists of homomogeneous polynomials that generated the ideal of C. The set psi will actually generate the ideal of K_G[x_1,..,x_g] arising from C. The homogeneous polynomials in psi will all have degree 2 or 3 except in the case where X_G has genus 3 and is not geometrically hyperelliptic (in this case psi consists of a single quartic). If ""lll"" is true, we use the LLL algorithm to hopefully make the model nicer. The quantities ""prec0"" and ""prec_delta"" are technical parameters for the starting precision and increasing precision",0,1,0,0,0,0,0,0,0,270,,270,-38,-38,-38,-38,-38
S,FindModelOfXG,"Input: M: a record of type ""ModularCurveRec"" (for example produced as output of CreateModularCurveRec) that corresponds to a modular curve X_G. Function assumes that G contains -I. Output: An updated record M is returned with an explicit model computed. The polynomials cutting out the model can be found in M`psi. Details: The model is found by computing a K_G-subspace V of M_(k,G) given by extra vanishing conditions at the cusps. The k is a positive even integer stored as M`k and the multiplicity at the cusps is given by M`mult (with the same ordering of cusps as given by M). A Q-basis of V is given by M`F0. Let n be the dimension of V as a K_G-vector space; it agrees with #M`F0/M`KG_degree. The first n terms f_1,..,f_n of M`F0 is a K_G-basis of V. The set of polynomials M`psi generats the ideal of K_G[x_1,...,x_n] consisting of polynomials P for which P(f_1,...,f_n)=0. The ideal cuts out the model in P^(n-1)_(K_G). The set M`psi will always consist of homogeneous polynomials of degree 2 and 3. We use the canonical model whenever possible. If desired, the parameter G0 can be set to be an open subgroup of GL(2,Zhat) for which G=M`G is a normal subgroup. We then choose our model so that G0 acts on V. This makes it easy later to compute the automorphisms of our curve coming from G0/G. The quantities ""prec0"" and ""prec_delta"" are technical parameters for the starting precision and increasing precision",0,1,0,0,0,0,0,0,0,270,,270,-38,-38,-38,-38,-38
S,ConvertModularFormExpansions,"Input: M1, M2 : modular curves corresponding to X_G1 and X_G2, respectively, where Gi is an open subgroup of GL(2,Zhat). g : a matrix in GL(2,Zhat) (given as a matrix in GL(2,Z/N) where N is divisible by the level of G1) F : a sequence of (weakly) modular form on M1=X_G1; each modular forms is given as a sequence consisting of its q-expansion at the cusps of M1 (using M1`cusps). wt : the weight of each modular form in F; though we only use the value of wt modulo 2. We assume that for each modular form f in F, f*g is a modular form on M2=X_G2. Output: the sequence of modular forms f*g of M2=X_G2 with f in F. Note: If the wrong weight ""wt"" is given, the resulting output might be off by a sign",0,4,0,0,0,0,0,0,0,-1,,0,0,-1,,0,0,-1,,0,0,-1,,82,-38,-38,-38,-38,-38
S,FindModularForms,"Input k: an integer > 1, M: a modular curve given by a record of type ""ModularCurveRec"" (for example produced as output of CreateModularCurveRec) associated to an open subgroup G of GL(2,Zhat). Let N be the level of G. Output: The record M with M`F updated to consist of a basis of the space of modular forms M_(k,G) := M_k(Gamma(N),Q(zeta_N))^G as a vector space over Q. Let d be the dimension of M_(k,G) over K_G (note: d=#M`F div M`KG_degree). The first d modular forms in the sequence M`F will be a basis of M_(k,G) over K_G (moreover, they are linearly independent over C). A modular form is given as a sequence consisting of its q-expansion at each cusp (with the ordering of cusps coming from M`cusps). Enough terms of the q-expansions of each modular form is computed so that it is uniquely determined in M_(k,G). [M is returned with the following entries computed/updated: k, dimMk, dimSk, prec_sturm, prec, F] The technical parameters ""lll"" and ""saturation"" can adjust when the function takes saturations and applies LLL to matrices. The technical parameter ""prime_tolerance"" is for adjusting how often we consider new primes when computing rank of matrices via reduction",0,2,0,0,0,0,0,0,0,270,,0,0,148,,270,-38,-38,-38,-38,-38
S,IncreaseModularFormPrecision,"Input M: a modular curve given as a record of type ""ModularCurveRec"" for which M`F is defined and consist of modular forms (as outputted by ""FindModularForms""). prec: a sequence of positive integers; one integer for each cusp. Output: Returns M with the q-expansions of the modular forms in M`F extended so that they are computed at least up to O(q^(prec[i]/w_i) at the i-th cusp of M, where w_i is the width of the i-th cusp. This also extends the modular forms in M`F0 if present",0,2,0,0,0,0,0,0,0,82,,0,0,270,,270,-38,-38,-38,-38,-38
S,IncreaseModularFormPrecision,"Same as other version but q-expansions at all cusps are computed up to O(q^(prec/m)), where m=M`sl2level and prec is a nonnegative integer",0,2,0,0,0,0,0,0,0,148,,0,0,270,,270,-38,-38,-38,-38,-38
S,AutomorphismOfModularForms,"Input: a modular curve M=X_G, a sequence F of modular forms in M_(k,G) for some k>1 that are linearly independent over K_G, and a matrix g in GL(2,Zhat) that lies in the normalizer of G and acts on the K_G-vector V space spanned by F. (The parameter ""k"" is an integer congruent to k modulo 2.) Output: the matrix C that describes the action of g on V in terms of the basis F; it will be a square matrix with entries in K_G. When ""OverQ"" is set to true, then it performs as described above except with K_G replaced by Q",0,3,0,0,0,0,0,0,0,180,,0,0,82,,0,0,270,,82,-38,-38,-38,-38,-38
S,FindMorphismCanonical,"Input: Modular curves M and M0 corresponding to open subgroups G and G0 of GL(2,Zhat), respectively. Assume that G is a subgroup of G0 and hence we have a natural morphism X_G -> X_G0. When X_G and X_G0 are both given by a canonical model, this morphism is just a linear projection. Output: The tuple of linear polynomials corresponding to the projection",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,82,-38,-38,-38,-38,-38
S,FindMorphism,"Warning: this function is still very experimental! Input: Modular curves M and M0 corresponding to open subgroups G and G0 of GL(2,Zhat), respectively. Assume that G is a subgroup of G0 and hence we have a natural morphism X_G -> X_G0 defined over K_G. Assume also that G contains -I. We assume that models of X_G and X_G0 have already been computed. Output: With respect to their model, we give a tuple of homomogenous polynomials that corresponds to the morphism. Suppose that the parameter ""homogenous"" is set to false and the model of X_G or X_G0 is not canonical. Then a tuple of the form [1,F_1,...,F_n] is returned with F_i in the function field of X_G. Clearing denominators will give a tuple of homogenous polynomials as above. The function works by computing these F_i first and this express may me nicer for many purposes. The parameters ""prec0"" and ""prec_delta"" are for initial precision and how much to increase it when more is needed; these should be left alone at first. The parameters ""Id"" and ""mon1"" should be left alone; they are for keeping computations when we apply the function recursively",0,2,0,0,0,0,0,0,0,-1,,0,0,-1,,82,-38,-38,-38,-38,-38
S,FindRatio,"Warning: this function is still very experimental! Input: Modular curves M and M0 corresponding to open subgroups G and G0 of GL(2,Zhat), respectively. Assume that G=[pm I G0] and hence X_G0 is a fine modular curve and X_G is the coarse one. They are defined by the same equations. M0_(3,G0) is not trivial hence there is a weight 3 modular form f. We compute f^2/E6 as a rational function on X_G=X_G0 Output: Assumes the model for M is computed The function works by computing these F_i first and this express may me nicer for many purposes. The degree of the relations and the precision needed is not precomputed, we continue by increasing the degree and precision step by step. This function can be adjusted to compute other modular fucntions as a rational function. The parameters ""prec0"" and ""prec_delta"" are for initial precision and how much to increase it when more is needed; these should be left alone at first. The parameters ""Id"" and ""mon1"" should be left alone; they are for keeping computations when we apply the function recursively",0,3,0,0,0,0,0,0,0,-1,,0,0,-1,,0,0,-1,,82,-38,-38,-38,-38,-38
